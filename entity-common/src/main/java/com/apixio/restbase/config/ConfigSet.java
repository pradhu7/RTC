package com.apixio.restbase.config;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;

import org.yaml.snakeyaml.Yaml;

import com.apixio.datasource.consul.ConsulDS;

/**
 * Provides a convenient/different way to deal with yaml-based configuration that
 * defines a predictable and useful way to allow overriding of yaml-defined
 * configuration (on a command line, for example) by specifying the "flattened" yaml
 * keys.
 *
 * This class converts a yaml-constructed map-of-maps (where each submap is basically
 * the contents of the next indented level of yaml config) into a single level map
 * whose keys are the dotted path (in the yaml file) of the keys, and the value is
 * the yaml-converted value.
 *
 * For example, the following yaml (4 spaces per indent):
 *
 *  config:
 *      uri:  hdfs://...
 *      server:
 *          host:  blah.blah
 *
 * would produce a SINGLE Map<String, Object> object with the following key=value pairs:
 *
 *  config.uri=hdfs://...
 *  config.server.host=blah.blah
 *
 * (Note that this single map is in contrast to what SnakeYaml does by default.)
 *
 * The following types are allowed as a value:  Boolean, String, Double, Long,
 * Integer, and Lists of those types (but not lists of lists).  ConfigSet objects
 * can be efficiently (de)serialized to/from a string
 *
 * ConfigSet supports the concept of "boot macros" where a Map<String, String> is
 * used to substitute simple {name} macros for their corresponding values in the
 * overall set of loaded yaml values.
 */
public class ConfigSet
{
    /**
     * Separates the levels of yaml keys
     */
    public final static String KEY_SEPARATOR = ".";

    /**
     * If this instance was generated by getConfigSubtree, "derivedFrom" will hold
     * the "parent's" path so we can spit out useful info/errors.
     */
    private String derivedFrom = "";

    /**
     * The flattened map of key=>value
     */
    private Map<String, Object> loadedConfig = new HashMap<>();

    /**
     * Factory pattern to construct SysConfig instances.
     */
    public static ConfigSet emptyConfig()
    {
        return new ConfigSet();
    }

    public static ConfigSet duplicate(ConfigSet toDuplicate)
    {
        ConfigSet sysCfg = new ConfigSet();

        sysCfg.loadedConfig.putAll(toDuplicate.loadedConfig);
        sysCfg.derivedFrom = toDuplicate.derivedFrom;

        return sysCfg;
    }

    public static ConfigSet fromMap(Map<String, Object> mapOfMaps)
    {
        ConfigSet sysCfg = new ConfigSet();

        if (mapOfMaps == null)
            throw new IllegalArgumentException("Null map can't be used for ConfigSet");

        sysCfg.recurseInto("", mapOfMaps, sysCfg.loadedConfig);

        return sysCfg;
    }

    public static ConfigSet fromYamlFile(File yamlFile) throws IOException
    {
        InputStream is = null;

        try
        {
            is = new FileInputStream(yamlFile);

            return fromYamlStream(is);
        }
        finally
        {
            if (is != null)
                is.close();
        }
    }

    /**
     * Load configuration from .yaml file into generic Map.
     */
    public static ConfigSet fromYamlStream(InputStream input) throws IOException
    {
        Yaml        yaml   = new Yaml();
        Object      data   = yaml.load(input);

        input.close();

        return fromMap((Map<String, Object>) data);
    }

    /**
     * Load configuration from consul into generic Map.
     */
    public static ConfigSet fromConsul() throws IOException
    {
        return fromMap(ConsulDS.getConfig('.'));
    }

    public static ConfigSet deserialize(String serial)
    {
        ConfigSet  config = new ConfigSet();

        config.loadedConfig = ConfigSetUtil.mapFromString(serial);

        return config;
    }

    /**
     * Force use of factory
     */
    private ConfigSet()
    {
    }

    /**
     * merge adds all the configuration from the passed-in ConfigSet instance to this
     * instance, replacing any that exist in 'this' with those that exist in the passed-in
     * one (thus performing the override of what's currently in 'this').
     */
    public ConfigSet merge(ConfigSet overridesConfig)
    {
        return merge(overridesConfig.loadedConfig);
    }
    public ConfigSet merge(ConfigSet overridesConfig, boolean replaceOnly)
    {
        return merge(overridesConfig.loadedConfig, replaceOnly);
    }
    public ConfigSet merge(Map<String, Object> overridesConfig)
    {
        return merge(overridesConfig, false);
    }
    public ConfigSet merge(Map<String, Object> overridesConfig, boolean replaceOnly)
    {
        if (!replaceOnly)
        {
            this.loadedConfig.putAll(overridesConfig);
        }
        else
        {
            for (Map.Entry<String, Object> entry : overridesConfig.entrySet())
            {
                String key = entry.getKey();

                if (loadedConfig.containsKey(key))
                    loadedConfig.put(key, entry.getValue());
            }
        }

        return this;
    }

    /**
     * Returns the underlying map of propnames to values.
     */
    public Map<String, Object> getProperties()
    {
        return loadedConfig;
    }

    /**
     * Returns a new ConfigSet that contains only those keys that have the given prefix. It
     * also removes the prefix that matched.
     */
    public ConfigSet getConfigSubtree(String prefix)
    {
        Map<String, Object>  subset = new HashMap<>();
        ConfigSet            subCfg = null;
        int                  plen;

        if (!prefix.endsWith(KEY_SEPARATOR))
            prefix += KEY_SEPARATOR;

        plen = prefix.length();

        for (Map.Entry<String, Object> entry : loadedConfig.entrySet())
        {
            String key = entry.getKey();

            if (key.startsWith(prefix))
                subset.put(key.substring(plen), entry.getValue());
        }

        if (subset.size() > 0)
        {
            subCfg = new ConfigSet();

            subCfg.loadedConfig = subset;   // cheap clone/ctor
            subCfg.derivedFrom  = derivedFrom + prefix;
        }

        return subCfg;
    }

    /**
     * Serialize to a String that can be used by the static deserialize() method.  This is a non-JSON
     * serialization (gasp!) that prefixes the type of the value before the value, like "int:1".
     * This is partly for performance (vs jackson) and partly to reduce dependencies and partly for fun.
     * A value that is of type List<scalar> is supported by transforming the single value into multiple
     * key=value (one for each element of the list).  The "main" value for the key is of the form
     *
     *  "list":type:nnn
     *
     * where type is the normal scalar type indicator, and nnn is the number of elements in the list.
     */
    public String serialize()
    {
        return ConfigSetUtil.mapToString(loadedConfig);
    }

    /**
     * Getters/extractors.  General pattern is that a the non-default method getXyz(String key)
     * will throw an exception if the config value isn't found (or if the type is wrong), and
     * that the method getXyz(String key, Type defVal) will return a full object (e.g., boxed
     * primitive).
     */

    /**
     * getLong is the most interesting as it needs to deal with both Integer and Long
     */
    public long getLong(String key)
    {
        Object val = getRequired(key, "long");

        // snakeyaml prefers ints over longs
        if (val instanceof Long)
            return ((Long) val).longValue();
        else if (val instanceof Integer)
            return ((Integer) val).longValue();
        else
            validateType(key, val, Long.class);

        return 0L;  // only for compilation as validateType should throw an exception
    }
    public Long getLong(String key, Long def)
    {
        Object val = loadedConfig.get(key);

        // snakeyaml prefers ints over longs
        if (val == null)
            return def;
        else if (val instanceof Long)
            return (Long) val;
        else if (val instanceof Integer)
            return Long.valueOf(((Integer) val).longValue());
        else
            validateType(key, val, Long.class);

        return null;
    }

    /**
     *
     */
    public int getInteger(String key)
    {
        Object val = getRequired(key, "integer");

        validateType(key, val, Integer.class);

        return (Integer) val;
    }
    public Integer getInteger(String key, Integer def)
    {
        Object val = loadedConfig.get(key);

        validateType(key, val, Integer.class);

        return (val != null) ? ((Integer) val) : def;
    }


    /**
     *
     */
    public double getDouble(String key)
    {
        Object val = getRequired(key, "double");

        validateType(key, val, Double.class);

        return (Double) val;
    }

    public Double getDouble(String key, Double def)
    {
        Object val = loadedConfig.get(key);

        validateType(key, val, Double.class);

        return (val != null) ? ((Double) val) : def;
    }

    /**
     *
     */
    public boolean getBoolean(String key)
    {
        Object val = getRequired(key, "boolean");

        validateType(key, val, Boolean.class);

        return ((Boolean) val).booleanValue();
    }
    public Boolean getBoolean(String key, Boolean def)
    {
        Object val = loadedConfig.get(key);

        validateType(key, val, Boolean.class);

        return (val != null) ? ((Boolean) val) : def;
    }

    /**
     *
     */
    public String getString(String key)
    {
        Object val = getRequired(key, "string");

        validateType(key, val, String.class);

        return (String) val;
    }
    public String getString(String key, String def)
    {
        Object val = loadedConfig.get(key);

        validateType(key, val, String.class);

        return (val != null) ? ((String) val) : def;
    }

    /**
     *
     */
    public List<Object> getList(String key)
    {
        Object val = loadedConfig.get(key);

        validateType(key, val, List.class);

        return (List<Object>) val;
    }

    /**
     * getXyz() support
     */
    private Object getRequired(String key, String expectedType)
    {
        Object val = loadedConfig.get(key);

        if (val == null)
            throw new IllegalArgumentException("Expected configuration for key [" + derivedFrom + key + "] with type " + expectedType);

        return val;
    }

    private void validateType(String key, Object val, Class expected)
    {
        if ((val != null) && !expected.isAssignableFrom(val.getClass()))
            throw new IllegalArgumentException("configuration value for key [" + derivedFrom + key + "] with value [" + val + "] should have type " +
                                               expected.getCanonicalName() + " but had type " + val.getClass().getCanonicalName());
    }

    /**
     * Recursive method to walk yaml config tree flattening the key names before
     * putting them into the final flat map.
     */
    private void recurseInto(String prefix, Map<String, Object> tree, Map<String, Object> flat)
    {
        if (prefix.length() > 0)
            prefix = prefix + KEY_SEPARATOR;

        for (Map.Entry<String, Object> entry : tree.entrySet())
        {
            String key = prefix + entry.getKey();
            Object val = entry.getValue();

            if (val == null)
            {
                // ignore odd (possibly impossible?) case
            }
            else if ((val instanceof String) || (val instanceof ConfigExpression) || isScalar(val))
            {
                flat.put(key, val);
            }
            else if (val instanceof List)
            {
                List<Object> list = (List<Object>) val;

                if (validateScalars(key, list))
                    flat.put(key, list);
            }
            else if (val instanceof Map)
            {
                recurseInto(key, (Map) val, flat);
            }
            else
            {
                warning("Config key '" + key + "':  ignoring unsupported config value type '" + val + "'");
            }
        }
    }

    /**
     * Scan values for strings that can have macros replaced.
     */
    public void applyBootProperties(Map<String, String> bootProps)
    {
        if (bootProps != null)
        {
            for (Map.Entry<String, Object> entry : loadedConfig.entrySet())
            {
                String key = entry.getKey();
                Object val = entry.getValue();

                if (val instanceof String)
                {
                    String strValue = (String) val;
                    String repValue = MacroUtil.replaceMacros(bootProps, false, strValue);

                    if (!strValue.equals(repValue))   // convert only if macro sub did something
                        val = convertIfPossible(repValue);

                    loadedConfig.put(key, val);
                }
                else if (val instanceof List)
                {
                    List<Object> list = (List<Object>) val;

                    replaceMacros(list, bootProps);

                    loadedConfig.put(key, list);
                }
            }
        }
    }

    /**
     * Try to convert from String to one of the non-list scalar forms.  This is necessary
     * to support macros with default values that are supposed to non-string.
     */
    private Object convertIfPossible(String val)
    {
        // easy ones in non-standard code format that's easier to understand
        try { return Integer.valueOf(val); } catch (Exception x) { }
        try { return Long.valueOf(val);    } catch (Exception x) { }
        try { return Double.valueOf(val);  } catch (Exception x) { }

        // Boolean.valueOf is messed up
        if (val.equalsIgnoreCase(Boolean.TRUE.toString()))
            return Boolean.TRUE;
        else if (val.equalsIgnoreCase(Boolean.FALSE.toString()))
            return Boolean.FALSE;
        else
            return val;
    }

    private void replaceMacros(List<Object> list, Map<String, String> macros)
    {
        for (ListIterator<Object> li = list.listIterator(); li.hasNext();)
        {
            Object ele = li.next();

            if (ele instanceof String)
                li.set(MacroUtil.replaceMacros(macros, false, (String) ele));
        }
    }

    private boolean isScalar(Object o)
    {
        return ((o instanceof Boolean) ||
                (o instanceof Double)  ||
                (o instanceof Integer) ||
                (o instanceof Long)    ||
                (o instanceof String));
    }

    private boolean validateScalars(String key, List<Object> list)
    {
        for (Object ele : list)
        {
            if ((ele != null) && !isScalar(ele))
            {
                warning("Config key '" + key + "':  ignoring list config value as at least one element is not scalar (string, bool, number): " + ele + " with .class=" + ele.getClass());

                return false;
            }
        }

        return true;
    }

    /**
     *
     */
    private void warning(String message)
    {
        System.out.print("WARN:  ");
        System.out.println(message);
    }

    /**
     *
     */
    @Override
    public String toString()
    {
        return loadedConfig.toString();
    }

}
