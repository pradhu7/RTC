package com.apixio.sdk;

import java.io.File;
import java.io.IOException;
import java.net.Socket;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.nio.file.Files;
import java.nio.file.attribute.PosixFilePermission;

import com.apixio.sdk.protos.FxProtos.FxImpl;
import com.apixio.sdk.protos.FxProtos.FxTag;
import com.apixio.sdk.protos.FxProtos.FxType;
import com.apixio.sdk.util.TypeUtil;

import org.apache.commons.lang.NotImplementedException;


/**
 * SvcFxInvokable invokes Fx's that are accessible via an HTTP call. The actual API call is made vy SvcFxImplementation,
 * but most of the interesting work happens here:
 * 
 * 1) It has to make sure the child process is running
 * 2) It has to convert all arguments and outputs to/from protobuf
 */
public class SvcFxInvokable<T> extends FxInvokable<T> {
    // TODO: ask Scott where to store this config
    int SVC_PORT = 4500;
    // TODO: this number should be generated by inspecting the hardware. David says ECC already does this somewhere
    int     numProcesses    = 3;
    // TODO Is this in the setEnvironment config?
    String  loggingHost     = "localhost";
    int     loggingPort     = 24224;

    FxImplLogWrapper implwrapper = null;
    SvcFxImplementation implInstance = null;
    URI invokeUri = null;
    // Converters are needed to convert arguments and outputs to/from protobuf
    private HashMap<FxType, Converter> implConverters;

    public SvcFxInvokable(FxLogger logger, FxImpl impl, String invokeUri, HashMap<FxType, Converter> implConverters) throws URISyntaxException {
        super(logger, impl);
        this.invokeUri = new URI(invokeUri.startsWith("file:") ? invokeUri: "file:" + invokeUri);
        this.implConverters = implConverters;
        implInstance = new SvcFxImplementation(fxImpl.getEntryName(), "http://localhost:" + SVC_PORT + "/apxsdk");
        implwrapper = new FxImplLogWrapper((FxImplementation) implInstance, fxImpl.getEntryName());
    }

    public Class<?>[] getParameterTypes()
    {
        List<FxType> params = this.fxDef.getParametersList();
        Class<?>[] types = new Class<?>[params.size()];
        for (int i=0; i < types.length; i++) {
            FxType type = params.get(i);
            if (type.getTag() == FxTag.SEQUENCE) {
                types[i] = List.class;
            } else {
                // TODO Not Implemented
                types[i] = String.class;
                throw new NotImplementedException("currently only handles list arguments");
            }
        }
        return types;
    }

    public void callSetup(FxEnvironment env) throws Exception
    {
        implwrapper.setEnvironment(env);
        logger.info("Calling setup on " + invokeUri);
        setupFxService(new File(invokeUri), true);
    }

    public Object invokeInner(List<FxType> argTypes, Object[] args) throws Exception
    {
        // This call checks to see if service is still running. If not, restart
        setupFxService(new File(invokeUri), false);

        // Gather arguments and convert them to structures that will tell service how to parse them
        List<Object> arglist = new ArrayList<>();
        for (int i=0; i < argTypes.size(); i++) {
            Object arg = args[i];
            FxType argType = argTypes.get(i);
            Object dataString = null;
            if (arg instanceof List) {
                List<String> argProtoStrs = ((List<Object>) arg).stream()
                .map(k -> TypeUtil.interfaceToProtoString(implConverters.get(argType), k))
                .collect(Collectors.toList());
                dataString = argProtoStrs;
            } else {
                dataString = TypeUtil.interfaceToProtoString(implConverters.get(argType), arg);
            }
            
            Map<String, Object> argdetails = new HashMap<>();
            argdetails.put("type", TypeUtil.protoToBase64String(argType));
            argdetails.put("data", dataString);
            arglist.add(argdetails);
        }
        // Execute F(x)
        FxType outtype = fxDef.getReturns();
        String result = (String) implInstance.invoke(arglist, outtype);
        // Parse output and return as interface objects
        Converter outconverter = implConverters.get(outtype);
        if (outtype.getTag() == FxTag.SEQUENCE) {
            List<Object> results = TypeUtil.convertJsonListToInterfaces(outconverter, result);
            return results;
        }
        throw new NotImplementedException("Currently, SvcFxInvokable only handles sequence outputs");
    }

    /**
     * Check to see if the service is running. If not, start it and set assets. If forceSetAssets is true,
     * setAssets even if the service is already running (for the case where an external source starts the service).
     * @param svcPath The executable that will start the service
     * @param forceSetAssets If true, will call setAssets on the service even if it is already runnning.
     * 
     * @throws Exception
     */
    protected void setupFxService(File svcPath, boolean forceSetAssets) throws Exception {
        String host = "localhost";
        if (svcPath == null) {
            return;
        }
        boolean isRunning = checkService(host, SVC_PORT);
        if (!isRunning) {
            String localexec = "./pyexec";
            String[] cpparams = new String [] { "cp", svcPath.getAbsolutePath(), localexec};
            Runtime.getRuntime().exec(cpparams);
            TimeUnit.SECONDS.sleep(1);

            Set<PosixFilePermission> perms = new HashSet<PosixFilePermission>();
            perms.add(PosixFilePermission.OWNER_EXECUTE);
            perms.add(PosixFilePermission.OWNER_READ);
            perms.add(PosixFilePermission.OWNER_WRITE);
            Files.setPosixFilePermissions(svcPath.toPath(), perms);

            String[] params = new String [] { localexec, String.valueOf(SVC_PORT),
                                              String.valueOf(numProcesses), loggingHost, String.valueOf(loggingPort)};
            try {
                String[] envp = { "TMP=." };
                Runtime.getRuntime().exec(params, envp);
                // We'll give the external service many seconds to init
                int MAX_INIT_TIME_SECONDS = 30; // TODO ask scott about config
                for (int i = 0; i < MAX_INIT_TIME_SECONDS && !checkService(host, SVC_PORT); i++) {
                    TimeUnit.SECONDS.sleep(1);
                } 
            } catch (IOException e) {
                logger.error("Could not start " + svcPath, e);
                e.printStackTrace();
            }
            if (!checkService(host, SVC_PORT)) {
                logger.error("Could not start " + svcPath);
                throw new Exception("Could not start service: " + svcPath.getAbsolutePath());
            }
        }
        if (!isRunning || forceSetAssets) {
            logger.debug("Setting assets for " + svcPath);
            implwrapper.setAssets(fxImpl.getAssetsMap());
        }
    }

    /**
     * Check to see if the service is running by creating a socket on that port.
     * 
     * @param host Host for the service
     * @param port Port for the service.
     */
    protected boolean checkService(String host, int port) {
        try (Socket s = new Socket(host, port)) {
            s.close();
            logger.debug("Service is running at " + host + ":" + port);
            return true;
        } catch (IOException ex) {
            /* ignore */
        }
        logger.debug("Service is NOT running at " + host + ":" + port);
        return false;
    }
}
